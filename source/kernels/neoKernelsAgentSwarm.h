// ----------------------------------------------------------------------------
//  OgmaNeo
//  Copyright(c) 2016 Ogma Intelligent Systems Corp. All rights reserved.
//
//  This copy of OgmaNeo is licensed to you under the terms described
//  in the OGMANEO_LICENSE.md file included in this distribution.
// ----------------------------------------------------------------------------

#pragma once

#if !defined(_NEOKERNELSAGENTSWARM_OCL_HEADER)
#define _NEOKERNELSAGENTSWARM_OCL_HEADER

#include <string>

const std::string neoKernelsAgentSwarm_ocl[] = {
"// ----------------------------------------------------------------------------\n",
"//  OgmaNeo\n",
"//  Copyright(c) 2016 Ogma Intelligent Systems Corp. All rights reserved.\n",
"//\n",
"//  This copy of OgmaNeo is licensed to you under the terms described\n",
"//  in the OGMANEO_LICENSE.md file included in this distribution.\n",
"// ----------------------------------------------------------------------------\n",
"\n",
"// ----------------------------------------- Samplers -----------------------------------------\n",
"\n",
"constant sampler_t defaultSampler = CLK_NORMALIZED_COORDS_FALSE |\n",
"    CLK_ADDRESS_CLAMP_TO_EDGE |\n",
"    CLK_FILTER_NEAREST;\n",
"\n",
"constant sampler_t normalizedClampedNearestSampler = CLK_NORMALIZED_COORDS_TRUE |\n",
"    CLK_ADDRESS_CLAMP |\n",
"    CLK_FILTER_NEAREST;\n",
"\n",
"constant sampler_t normalizedClampedToEdgeNearestSampler = CLK_NORMALIZED_COORDS_TRUE |\n",
"    CLK_ADDRESS_CLAMP_TO_EDGE |\n",
"    CLK_FILTER_NEAREST;\n",
"\n",
"constant sampler_t unnormalizedClampedNearestSampler = CLK_NORMALIZED_COORDS_FALSE |\n",
"    CLK_ADDRESS_CLAMP |\n",
"    CLK_FILTER_NEAREST;\n",
"\n",
"constant sampler_t defaultNormalizedSampler = CLK_NORMALIZED_COORDS_TRUE |\n",
"    CLK_ADDRESS_CLAMP_TO_EDGE |\n",
"    CLK_FILTER_NEAREST;\n",
"\n",
"constant sampler_t defaultUnnormalizedSampler = CLK_NORMALIZED_COORDS_FALSE |\n",
"    CLK_ADDRESS_CLAMP_TO_EDGE |\n",
"    CLK_FILTER_NEAREST;\n",
"\n",
"// ----------------------------------------- Common -----------------------------------------\n",
"\n",
"float randFloat(uint2* state) {\n",
"    const float invMaxInt = 1.0f / 4294967296.0f;\n",
"    uint x = (*state).x * 17 + (*state).y * 13123;\n",
"    (*state).x = (x << 13) ^ x;\n",
"    (*state).y ^= (x << 7);\n",
"\n",
"    uint tmp = x * (x * x * 15731 + 74323) + 871483;\n",
"\n",
"    return convert_float(tmp) * invMaxInt;\n",
"}\n",
"\n",
"float randNormal(uint2* state) {\n",
"    float u1 = randFloat(state);\n",
"    float u2 = randFloat(state);\n",
"\n",
"    return sqrt(-2.0f * log(u1)) * cos(6.28318f * u2);\n",
"}\n",
"\n",
"float sigmoid(float x) {\n",
"    return 1.0f / (1.0f + exp(-x));\n",
"}\n",
"\n",
"float relu(float x, float leak) {\n",
"    x += 0.5f;\n",
"\n",
"    if (x > 1.0f)\n",
"        return 1.0f + (x - 1.0f) * leak;\n",
"\n",
"    return x > 0.0f ? x : x * leak;\n",
"}\n",
"\n",
"float relud(float x, float leak) {\n",
"    x += 0.5f;\n",
"\n",
"    return x > 0.0f && x < 1.0f ? 1.0f : leak;\n",
"}\n",
"\n",
"bool inBounds0(int2 position, int2 upperBound) {\n",
"    return position.x >= 0 && position.x < upperBound.x && position.y >= 0 && position.y < upperBound.y;\n",
"}\n",
"\n",
"bool inBounds(int2 position, int2 lowerBound, int2 upperBound) {\n",
"    return position.x >= lowerBound.x && position.x < upperBound.x && position.y >= lowerBound.y && position.y < upperBound.y;\n",
"}\n",
"\n",
"int2 project(int2 position, float2 toScalars) {\n",
"    return (int2)(position.x * toScalars.x + 0.5f, position.y * toScalars.y + 0.5f);\n",
"}\n",
"\n",
"// Initialize a random uniform 2D image (X field)\n",
"void kernel randomUniform2D(write_only image2d_t values, uint2 seed, float2 minMax) {\n",
"    uint2 seedValue = seed + (uint2)(get_global_id(0) * 29 + 12, get_global_id(1) * 16 + 23) * 36;\n",
"\n",
"    int2 position = (int2)(get_global_id(0), get_global_id(1));\n",
"\n",
"    float value = randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x;\n",
"\n",
"    write_imagef(values, position, (float4)(value, 0.0f, 0.0f, 0.0f));\n",
"}\n",
"\n",
"// Initialize a random uniform 3D image (X field)\n",
"void kernel randomUniform3D(write_only image3d_t values, uint2 seed, float2 minMax) {\n",
"    uint2 seedValue = seed + (uint2)(get_global_id(0) * 12 + 76 + get_global_id(2) * 3, get_global_id(1) * 21 + 42 + get_global_id(2) * 7) * 12;\n",
"\n",
"    int3 position = (int3)(get_global_id(0), get_global_id(1), get_global_id(2));\n",
"\n",
"    float value = randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x;\n",
"\n",
"    write_imagef(values, (int4)(position, 0), (float4)(value, 0.0f, 0.0f, 0.0f));\n",
"}\n",
"\n",
"// Initialize a random uniform 2D image (XY fields)\n",
"void kernel randomUniform2DXY(write_only image2d_t values, uint2 seed, float2 minMax) {\n",
"    uint2 seedValue = seed + (uint2)(get_global_id(0) * 15 + 66, get_global_id(1) * 61 + 2) * 56;\n",
"\n",
"    int2 position = (int2)(get_global_id(0), get_global_id(1));\n",
"\n",
"    float2 v = (float2)(randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x, randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x);\n",
"\n",
"    write_imagef(values, position, (float4)(v.x, v.y, 0.0f, 0.0f));\n",
"}\n",
"\n",
"// Initialize a random uniform 2D image (XYZ fields)\n",
"void kernel randomUniform2DXYZ(write_only image2d_t values, uint2 seed, float2 minMax) {\n",
"    uint2 seedValue = seed + (uint2)(get_global_id(0) * 15 + 66, get_global_id(1) * 61 + 2) * 56;\n",
"\n",
"    int2 position = (int2)(get_global_id(0), get_global_id(1));\n",
"\n",
"    float3 v = (float3)(randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x, randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x, randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x);\n",
"\n",
"    write_imagef(values, position, (float4)(v.x, v.y, v.z, 0.0f));\n",
"}\n",
"\n",
"// Initialize a random uniform 2D image (XZ fields)\n",
"void kernel randomUniform2DXZ(write_only image2d_t values, uint2 seed, float2 minMax) {\n",
"    uint2 seedValue = seed + (uint2)(get_global_id(0) * 29 + 12, get_global_id(1) * 16 + 23) * 36;\n",
"\n",
"    int2 position = (int2)(get_global_id(0), get_global_id(1));\n",
"\n",
"    float2 v = (float2)(randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x, randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x);\n",
"\n",
"    write_imagef(values, position, (float4)(v.x, 0.0f, v.y, 0.0f));\n",
"}\n",
"\n",
"// Initialize a random uniform 3D image (XY fields)\n",
"void kernel randomUniform3DXY(write_only image3d_t values, uint2 seed, float2 minMax) {\n",
"    uint2 seedValue = seed + (uint2)(get_global_id(0) * 12 + 76 + get_global_id(2) * 3, get_global_id(1) * 21 + 42 + get_global_id(2) * 7) * 12;\n",
"\n",
"    int3 position = (int3)(get_global_id(0), get_global_id(1), get_global_id(2));\n",
"\n",
"    float2 v = (float2)(randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x, randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x);\n",
"\n",
"    write_imagef(values, (int4)(position, 0), (float4)(v.x, v.y, 0.0f, 0.0f));\n",
"}\n",
"\n",
"// Initialize a random uniform 3D image (XZ fields)\n",
"void kernel randomUniform3DXZ(write_only image3d_t values, uint2 seed, float2 minMax) {\n",
"    uint2 seedValue = seed + (uint2)(get_global_id(0) * 12 + 76 + get_global_id(2) * 3, get_global_id(1) * 21 + 42 + get_global_id(2) * 7) * 12;\n",
"\n",
"    int3 position = (int3)(get_global_id(0), get_global_id(1), get_global_id(2));\n",
"\n",
"    float2 v = (float2)(randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x, randFloat(&seedValue) * (minMax.y - minMax.x) + minMax.x);\n",
"\n",
"    write_imagef(values, (int4)(position, 0), (float4)(v.x, 0.0f, v.y, 0.0f));\n",
"}\n",
"// ----------------------------------------------------------------------------\n",
"//  OgmaNeo\n",
"//  Copyright(c) 2016 Ogma Intelligent Systems Corp. All rights reserved.\n",
"//\n",
"//  This copy of OgmaNeo is licensed to you under the terms described\n",
"//  in the OGMANEO_LICENSE.md file included in this distribution.\n",
"// ----------------------------------------------------------------------------\n",
"\n",
"// -------------------------------------- Agent Layer ---------------------------------------\n",
"\n",
"void kernel alActivate(read_only image2d_t hiddenStates,\n",
"    read_only image3d_t weights,\n",
"    read_only image2d_t hiddenSummationBack, write_only image2d_t hiddenSummationFront,\n",
"    int2 hiddenSize, float2 qToHidden, int radius)\n",
"{\n",
"    int2 qPosition = (int2)(get_global_id(0), get_global_id(1));\n",
"    int2 hiddenPositionCenter = project(qPosition, qToHidden);\n",
"\n",
"    float sum = read_imagef(hiddenSummationBack, defaultSampler, qPosition).x;\n",
"\n",
"    float q = 0.0f;\n",
"\n",
"    int2 fieldLowerBound = hiddenPositionCenter - (int2)(radius);\n",
"\n",
"    for (int dx = -radius; dx <= radius; dx++)\n",
"        for (int dy = -radius; dy <= radius; dy++) {\n",
"            int2 hiddenPosition = hiddenPositionCenter + (int2)(dx, dy);\n",
"\n",
"            if (inBounds0(hiddenPosition, hiddenSize)) {\n",
"                int2 offset = hiddenPosition - fieldLowerBound;\n",
"\n",
"                int wi = offset.y + offset.x * (radius * 2 + 1);\n",
"\n",
"                float weight = read_imagef(weights, defaultSampler, (int4)(qPosition.x, qPosition.y, wi, 0)).x;\n",
"\n",
"                float state = read_imagef(hiddenStates, defaultSampler, hiddenPosition).x;\n",
"\n",
"                q += state * weight;\n",
"            }\n",
"        }\n",
"\n",
"    write_imagef(hiddenSummationFront, qPosition, (float4)(sum + q, 0.0f, 0.0f, 0.0f));\n",
"}\n",
"\n",
"void kernel alLearnQ(read_only image2d_t hiddenStates,\n",
"    read_only image2d_t qStates, read_only image2d_t qStatesPrev,\n",
"    read_only image2d_t tdErrors,\n",
"    read_only image3d_t weightsBack, write_only image3d_t weightsFront,\n",
"    int2 hiddenSize, float2 qToHidden, int radius, float alpha, float lambda)\n",
"{\n",
"    int2 qPosition = (int2)(get_global_id(0), get_global_id(1));\n",
"    int2 hiddenPositionCenter = project(qPosition, qToHidden);\n",
"\n",
"    float tdError = read_imagef(tdErrors, defaultSampler, qPosition).x;\n",
"    float qState = read_imagef(qStates, defaultSampler, qPosition).x;\n",
"    float qStatePrev = read_imagef(qStatesPrev, defaultSampler, qPosition).x;\n",
"\n",
"    int2 fieldLowerBound = hiddenPositionCenter - (int2)(radius);\n",
"\n",
"    for (int dx = -radius; dx <= radius; dx++)\n",
"        for (int dy = -radius; dy <= radius; dy++) {\n",
"            int2 hiddenPosition = hiddenPositionCenter + (int2)(dx, dy);\n",
"\n",
"            if (inBounds0(hiddenPosition, hiddenSize)) {\n",
"                int2 offset = hiddenPosition - fieldLowerBound;\n",
"\n",
"                int wi = offset.y + offset.x * (radius * 2 + 1);\n",
"\n",
"                float2 weightPrev = read_imagef(weightsBack, defaultSampler, (int4)(qPosition.x, qPosition.y, wi, 0)).xy;\n",
"\n",
"                float state = read_imagef(hiddenStates, defaultSampler, hiddenPosition).x;\n",
"\n",
"                float2 weight = (float2)(weightPrev.x + alpha * fmin(1.0f, fmax(-1.0f, tdError)) * weightPrev.y, fmax(lambda * weightPrev.y, state));\n",
"\n",
"                write_imagef(weightsFront, (int4)(qPosition.x, qPosition.y, wi, 0), (float4)(weight.x, weight.y, 0.0f, 0.0f));\n",
"            }\n",
"        }\n",
"}\n",
"\n",
"void kernel alLearnActions(read_only image2d_t hiddenStates, read_only image2d_t actionProbabilities,\n",
"    read_only image2d_t tdErrors, read_only image2d_t oneHotActions,\n",
"    read_only image3d_t weightsBack, write_only image3d_t weightsFront,\n",
"    int2 hiddenSize, float2 aToHidden, int radius, float alpha, float lambda, int2 subActionDims, float maxActionWeightMag)\n",
"{\n",
"    int2 aPosition = (int2)(get_global_id(0), get_global_id(1));\n",
"    int2 hiddenPositionCenter = project(aPosition, aToHidden);\n",
"\n",
"    float tdError = read_imagef(tdErrors, defaultSampler, (int2)(aPosition.x / subActionDims.x, aPosition.y / subActionDims.y)).x;\n",
"    float2 oneHotAction = read_imagef(oneHotActions, defaultSampler, aPosition).xy;\n",
"\n",
"	float probability = read_imagef(actionProbabilities, defaultSampler, aPosition).x;\n",
"\n",
"    int2 fieldLowerBound = hiddenPositionCenter - (int2)(radius);\n",
"\n",
"    for (int dx = -radius; dx <= radius; dx++)\n",
"        for (int dy = -radius; dy <= radius; dy++) {\n",
"            int2 hiddenPosition = hiddenPositionCenter + (int2)(dx, dy);\n",
"\n",
"            if (inBounds0(hiddenPosition, hiddenSize)) {\n",
"                int2 offset = hiddenPosition - fieldLowerBound;\n",
"\n",
"                int wi = offset.y + offset.x * (radius * 2 + 1);\n",
"\n",
"                float2 weightPrev = read_imagef(weightsBack, defaultSampler, (int4)(aPosition.x, aPosition.y, wi, 0)).xy;\n",
"\n",
"                float state = read_imagef(hiddenStates, defaultSampler, hiddenPosition).x;\n",
"\n",
"                float2 weight = (float2)(weightPrev.x + alpha * tdError * weightPrev.y, lambda * weightPrev.y + oneHotAction.y * (1.0f - lambda) * (oneHotAction.x - probability) * state);\n",
"\n",
"                write_imagef(weightsFront, (int4)(aPosition.x, aPosition.y, wi, 0), (float4)(fmin(maxActionWeightMag, fmax(-maxActionWeightMag, weight.x)), weight.y, 0.0f, 0.0f));\n",
"            }\n",
"        }\n",
"}\n",
"\n",
"void kernel alActionToOneHot(read_only image2d_t hiddenStates, read_only image2d_t actions, write_only image2d_t oneHotActions, int2 subActionDims, uchar modulate) {\n",
"    int2 position = (int2)(get_global_id(0), get_global_id(1));\n",
"\n",
"    float hiddenState = modulate ? read_imagef(hiddenStates, defaultSampler, position).x : 1.0f;\n",
"\n",
"    float action = read_imagef(actions, defaultSampler, position).x;\n",
"\n",
"    int actioni = (int)(round(action));\n",
"\n",
"    int2 actionPosition = position * subActionDims + (int2)(actioni % subActionDims.x, actioni / subActionDims.x);\n",
"\n",
"    for (int x = 0; x < subActionDims.x; x++)\n",
"        for (int y = 0; y < subActionDims.y; y++) {\n",
"            int index = x + y * subActionDims.x;\n",
"\n",
"            int2 subPosition = position * subActionDims + (int2)(x, y);\n",
"\n",
"            write_imagef(oneHotActions, subPosition, (float4)(index == actioni ? hiddenState : 0.0f));\n",
"        }\n",
"}\n",
"\n",
"void kernel alGetAction(read_only image2d_t activations, write_only image2d_t probabilities,\n",
"	write_only image2d_t actions, int2 subActionDims, uint2 seed)\n",
"{\n",
"    uint2 seedValue = seed + (uint2)(get_global_id(0) * 73 + 2, get_global_id(1) * 45 + 12) * 44;\n",
"\n",
"	int2 position = (int2)(get_global_id(0), get_global_id(1));\n",
"\n",
"	float expSum = 0.0f;\n",
"\n",
"	for (int x = 0; x < subActionDims.x; x++)\n",
"        for (int y = 0; y < subActionDims.y; y++) {\n",
"            float value = read_imagef(activations, defaultSampler, position * subActionDims + (int2)(x, y)).x;\n",
"\n",
"            expSum += exp(value);\n",
"        }\n",
"\n",
"    float select = randFloat(&seedValue);\n",
"\n",
"	int selectIndex = 0;\n",
"\n",
"	float sumSoFar = 0.0f;\n",
"\n",
"	uchar selected = 0;\n",
"\n",
"    for (int x = 0; x < subActionDims.x; x++)\n",
"        for (int y = 0; y < subActionDims.y; y++) {\n",
"			int2 subPosition = position * subActionDims + (int2)(x, y);\n",
"\n",
"            float value = read_imagef(activations, defaultSampler, subPosition).x;\n",
"\n",
"			float probability = exp(value) / expSum;\n",
"\n",
"			write_imagef(probabilities, subPosition, (float4)(probability, 0.0f, 0.0f, 0.0f));\n",
"\n",
"			sumSoFar += probability;\n",
"\n",
"            if (!selected && sumSoFar >= select) {\n",
"				selectIndex = x + y * subActionDims.x;\n",
"\n",
"				selected = 1;\n",
"			}\n",
"        }\n",
"\n",
"    write_imagef(actions, position, (float4)(selectIndex));\n",
"}\n",
"\n",
"void kernel alSetAction(read_only image2d_t modulator,\n",
"    read_only image2d_t actionsTaken, read_only image2d_t actionsTakenPrev,\n",
"    read_only image2d_t qStates, read_only image2d_t qStatesPrev, write_only image2d_t tdErrorsTrain, write_only image2d_t oneHotActions,\n",
"    int2 subActionDims, float reward, float gamma)\n",
"{\n",
"    int2 position = (int2)(get_global_id(0), get_global_id(1));\n",
"\n",
"    float modulate = read_imagef(modulator, defaultSampler, position).x;\n",
"\n",
"    float actionTaken = read_imagef(actionsTaken, defaultSampler, position).x;\n",
"    float actionTakenPrev = read_imagef(actionsTakenPrev, defaultSampler, position).x;\n",
"\n",
"    int actionTakeni = (int)(round(actionTaken));\n",
"    int actionTakenPrevi = (int)(round(actionTakenPrev));\n",
"\n",
"    float pred = read_imagef(qStates, defaultSampler, position).x;\n",
"    float predPrev = read_imagef(qStatesPrev, defaultSampler, position).x;\n",
"\n",
"    float tdError = reward + gamma * pred - predPrev;\n",
"    //float tdError = reward - predPrev;\n",
"\n",
"	write_imagef(tdErrorsTrain, position, (float4)(tdError, 0.0f, 0.0f, 0.0f));\n",
"\n",
"    for (int x = 0; x < subActionDims.x; x++)\n",
"        for (int y = 0; y < subActionDims.y; y++) {\n",
"            int index = x + y * subActionDims.x;\n",
"\n",
"            int2 subPosition = position * subActionDims + (int2)(x, y);\n",
"\n",
"			float act = index == actionTakeni ? 1.0f : 0.0f;\n",
"\n",
"            write_imagef(oneHotActions, subPosition, (float4)(act * modulate, modulate, 0.0f, 0.0f));\n",
"        }\n",
"}\n",
};

#endif
