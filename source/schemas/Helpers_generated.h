// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_HELPERS_OGMANEO_SCHEMAS_H_
#define FLATBUFFERS_GENERATED_HELPERS_OGMANEO_SCHEMAS_H_

#include "flatbuffers/flatbuffers.h"

namespace ogmaneo {
namespace schemas {

struct int2;

struct int4;

struct float2;

struct float4;

struct Vec2i;

struct Vec2f;

struct ValueField2D;

struct ImageFormat;

struct ByteArray;

struct ShortArray;

struct IntArray;

struct FloatArray;

struct Image2D;

struct Image3D;

struct DoubleBuffer2D;

struct DoubleBuffer3D;

enum ChannelOrder {
  ChannelOrder_CL_R = 4272,
  ChannelOrder_CL_A = 4273,
  ChannelOrder_CL_RG = 4274,
  ChannelOrder_CL_RA = 4275,
  ChannelOrder_CL_RGB = 4276,
  ChannelOrder_CL_RGBA = 4277,
  ChannelOrder_CL_BGRA = 4278,
  ChannelOrder_CL_ARGB = 4279,
  ChannelOrder_CL_INTENSITY = 4280,
  ChannelOrder_CL_LUMINANCE = 4281,
  ChannelOrder_CL_Rx = 4282,
  ChannelOrder_CL_RGx = 4283,
  ChannelOrder_CL_RGBx = 4284,
  ChannelOrder_CL_DEPTH = 4285,
  ChannelOrder_CL_DEPTH_STENCIL = 4286,
  ChannelOrder_CL_sRGB = 4287,
  ChannelOrder_CL_sRGBx = 4288,
  ChannelOrder_CL_sRGBA = 4289,
  ChannelOrder_CL_sBGRA = 4290,
  ChannelOrder_CL_ABGR = 4291,
  ChannelOrder_MIN = ChannelOrder_CL_R,
  ChannelOrder_MAX = ChannelOrder_CL_ABGR
};

inline const char **EnumNamesChannelOrder() {
  static const char *names[] = { "CL_R", "CL_A", "CL_RG", "CL_RA", "CL_RGB", "CL_RGBA", "CL_BGRA", "CL_ARGB", "CL_INTENSITY", "CL_LUMINANCE", "CL_Rx", "CL_RGx", "CL_RGBx", "CL_DEPTH", "CL_DEPTH_STENCIL", "CL_sRGB", "CL_sRGBx", "CL_sRGBA", "CL_sBGRA", "CL_ABGR", nullptr };
  return names;
}

inline const char *EnumNameChannelOrder(ChannelOrder e) { return EnumNamesChannelOrder()[static_cast<int>(e) - static_cast<int>(ChannelOrder_CL_R)]; }

enum ChannelDataType {
  ChannelDataType_CL_SNORM_INT8 = 4304,
  ChannelDataType_CL_SNORM_INT16 = 4305,
  ChannelDataType_CL_UNORM_INT8 = 4306,
  ChannelDataType_CL_UNORM_INT16 = 4307,
  ChannelDataType_CL_UNORM_SHORT_565 = 4308,
  ChannelDataType_CL_UNORM_SHORT_555 = 4309,
  ChannelDataType_CL_UNORM_INT_101010 = 4310,
  ChannelDataType_CL_SIGNED_INT8 = 4311,
  ChannelDataType_CL_SIGNED_INT16 = 4312,
  ChannelDataType_CL_SIGNED_INT32 = 4313,
  ChannelDataType_CL_UNSIGNED_INT8 = 4314,
  ChannelDataType_CL_UNSIGNED_INT16 = 4315,
  ChannelDataType_CL_UNSIGNED_INT32 = 4316,
  ChannelDataType_CL_HALF_FLOAT = 4317,
  ChannelDataType_CL_FLOAT = 4318,
  ChannelDataType_CL_UNORM_INT24 = 4319,
  ChannelDataType_MIN = ChannelDataType_CL_SNORM_INT8,
  ChannelDataType_MAX = ChannelDataType_CL_UNORM_INT24
};

inline const char **EnumNamesChannelDataType() {
  static const char *names[] = { "CL_SNORM_INT8", "CL_SNORM_INT16", "CL_UNORM_INT8", "CL_UNORM_INT16", "CL_UNORM_SHORT_565", "CL_UNORM_SHORT_555", "CL_UNORM_INT_101010", "CL_SIGNED_INT8", "CL_SIGNED_INT16", "CL_SIGNED_INT32", "CL_UNSIGNED_INT8", "CL_UNSIGNED_INT16", "CL_UNSIGNED_INT32", "CL_HALF_FLOAT", "CL_FLOAT", "CL_UNORM_INT24", nullptr };
  return names;
}

inline const char *EnumNameChannelDataType(ChannelDataType e) { return EnumNamesChannelDataType()[static_cast<int>(e) - static_cast<int>(ChannelDataType_CL_SNORM_INT8)]; }

enum PixelData {
  PixelData_NONE = 0,
  PixelData_ByteArray = 1,
  PixelData_ShortArray = 2,
  PixelData_IntArray = 3,
  PixelData_FloatArray = 4,
  PixelData_MIN = PixelData_NONE,
  PixelData_MAX = PixelData_FloatArray
};

inline const char **EnumNamesPixelData() {
  static const char *names[] = { "NONE", "ByteArray", "ShortArray", "IntArray", "FloatArray", nullptr };
  return names;
}

inline const char *EnumNamePixelData(PixelData e) { return EnumNamesPixelData()[static_cast<int>(e)]; }

template<typename T> struct PixelDataTraits {
  static const PixelData enum_value = PixelData_NONE;
};

template<> struct PixelDataTraits<ByteArray> {
  static const PixelData enum_value = PixelData_ByteArray;
};

template<> struct PixelDataTraits<ShortArray> {
  static const PixelData enum_value = PixelData_ShortArray;
};

template<> struct PixelDataTraits<IntArray> {
  static const PixelData enum_value = PixelData_IntArray;
};

template<> struct PixelDataTraits<FloatArray> {
  static const PixelData enum_value = PixelData_FloatArray;
};

inline bool VerifyPixelData(flatbuffers::Verifier &verifier, const void *union_obj, PixelData type);

MANUALLY_ALIGNED_STRUCT(4) int2 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  int2() { memset(this, 0, sizeof(int2)); }
  int2(const int2 &_o) { memcpy(this, &_o, sizeof(int2)); }
  int2(int32_t _x, int32_t _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  int32_t x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(int32_t _x) { flatbuffers::WriteScalar(&x_, _x); }
  int32_t y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(int32_t _y) { flatbuffers::WriteScalar(&y_, _y); }
};
STRUCT_END(int2, 8);

MANUALLY_ALIGNED_STRUCT(4) int4 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;
  int32_t w_;

 public:
  int4() { memset(this, 0, sizeof(int4)); }
  int4(const int4 &_o) { memcpy(this, &_o, sizeof(int4)); }
  int4(int32_t _x, int32_t _y, int32_t _z, int32_t _w)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)), w_(flatbuffers::EndianScalar(_w)) { }

  int32_t x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(int32_t _x) { flatbuffers::WriteScalar(&x_, _x); }
  int32_t y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(int32_t _y) { flatbuffers::WriteScalar(&y_, _y); }
  int32_t z() const { return flatbuffers::EndianScalar(z_); }
  void mutate_z(int32_t _z) { flatbuffers::WriteScalar(&z_, _z); }
  int32_t w() const { return flatbuffers::EndianScalar(w_); }
  void mutate_w(int32_t _w) { flatbuffers::WriteScalar(&w_, _w); }
};
STRUCT_END(int4, 16);

MANUALLY_ALIGNED_STRUCT(4) float2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  float2() { memset(this, 0, sizeof(float2)); }
  float2(const float2 &_o) { memcpy(this, &_o, sizeof(float2)); }
  float2(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float _x) { flatbuffers::WriteScalar(&x_, _x); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float _y) { flatbuffers::WriteScalar(&y_, _y); }
};
STRUCT_END(float2, 8);

MANUALLY_ALIGNED_STRUCT(4) float4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  float4() { memset(this, 0, sizeof(float4)); }
  float4(const float4 &_o) { memcpy(this, &_o, sizeof(float4)); }
  float4(float _x, float _y, float _z, float _w)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)), w_(flatbuffers::EndianScalar(_w)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float _x) { flatbuffers::WriteScalar(&x_, _x); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float _y) { flatbuffers::WriteScalar(&y_, _y); }
  float z() const { return flatbuffers::EndianScalar(z_); }
  void mutate_z(float _z) { flatbuffers::WriteScalar(&z_, _z); }
  float w() const { return flatbuffers::EndianScalar(w_); }
  void mutate_w(float _w) { flatbuffers::WriteScalar(&w_, _w); }
};
STRUCT_END(float4, 16);

MANUALLY_ALIGNED_STRUCT(4) Vec2i FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Vec2i() { memset(this, 0, sizeof(Vec2i)); }
  Vec2i(const Vec2i &_o) { memcpy(this, &_o, sizeof(Vec2i)); }
  Vec2i(int32_t _x, int32_t _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  int32_t x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(int32_t _x) { flatbuffers::WriteScalar(&x_, _x); }
  int32_t y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(int32_t _y) { flatbuffers::WriteScalar(&y_, _y); }
};
STRUCT_END(Vec2i, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2f() { memset(this, 0, sizeof(Vec2f)); }
  Vec2f(const Vec2f &_o) { memcpy(this, &_o, sizeof(Vec2f)); }
  Vec2f(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float _x) { flatbuffers::WriteScalar(&x_, _x); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float _y) { flatbuffers::WriteScalar(&y_, _y); }
};
STRUCT_END(Vec2f, 8);

MANUALLY_ALIGNED_STRUCT(4) ImageFormat FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t image_channel_order_;
  uint32_t image_channel_data_type_;

 public:
  ImageFormat() { memset(this, 0, sizeof(ImageFormat)); }
  ImageFormat(const ImageFormat &_o) { memcpy(this, &_o, sizeof(ImageFormat)); }
  ImageFormat(ChannelOrder _image_channel_order, ChannelDataType _image_channel_data_type)
    : image_channel_order_(flatbuffers::EndianScalar(static_cast<uint32_t>(_image_channel_order))), image_channel_data_type_(flatbuffers::EndianScalar(static_cast<uint32_t>(_image_channel_data_type))) { }

  ChannelOrder image_channel_order() const { return static_cast<ChannelOrder>(flatbuffers::EndianScalar(image_channel_order_)); }
  void mutate_image_channel_order(ChannelOrder _image_channel_order) { flatbuffers::WriteScalar(&image_channel_order_, static_cast<uint32_t>(_image_channel_order)); }
  ChannelDataType image_channel_data_type() const { return static_cast<ChannelDataType>(flatbuffers::EndianScalar(image_channel_data_type_)); }
  void mutate_image_channel_data_type(ChannelDataType _image_channel_data_type) { flatbuffers::WriteScalar(&image_channel_data_type_, static_cast<uint32_t>(_image_channel_data_type)); }
};
STRUCT_END(ImageFormat, 8);

struct ValueField2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT__DATA = 4,
    VT__SIZE = 6
  };
  const flatbuffers::Vector<float> *_data() const { return GetPointer<const flatbuffers::Vector<float> *>(VT__DATA); }
  flatbuffers::Vector<float> *mutable__data() { return GetPointer<flatbuffers::Vector<float> *>(VT__DATA); }
  const Vec2i *_size() const { return GetStruct<const Vec2i *>(VT__SIZE); }
  Vec2i *mutable__size() { return GetStruct<Vec2i *>(VT__SIZE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT__DATA) &&
           verifier.Verify(_data()) &&
           VerifyField<Vec2i>(verifier, VT__SIZE) &&
           verifier.EndTable();
  }
};

struct ValueField2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add__data(flatbuffers::Offset<flatbuffers::Vector<float>> _data) { fbb_.AddOffset(ValueField2D::VT__DATA, _data); }
  void add__size(const Vec2i *_size) { fbb_.AddStruct(ValueField2D::VT__SIZE, _size); }
  ValueField2DBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ValueField2DBuilder &operator=(const ValueField2DBuilder &);
  flatbuffers::Offset<ValueField2D> Finish() {
    auto o = flatbuffers::Offset<ValueField2D>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ValueField2D> CreateValueField2D(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> _data = 0,
    const Vec2i *_size = 0) {
  ValueField2DBuilder builder_(_fbb);
  builder_.add__size(_size);
  builder_.add__data(_data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ValueField2D> CreateValueField2DDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *_data = nullptr,
    const Vec2i *_size = 0) {
  return CreateValueField2D(_fbb, _data ? _fbb.CreateVector<float>(*_data) : 0, _size);
}

struct ByteArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA); }
  flatbuffers::Vector<uint8_t> *mutable_data() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct ByteArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) { fbb_.AddOffset(ByteArray::VT_DATA, data); }
  ByteArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ByteArrayBuilder &operator=(const ByteArrayBuilder &);
  flatbuffers::Offset<ByteArray> Finish() {
    auto o = flatbuffers::Offset<ByteArray>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ByteArray> CreateByteArray(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ByteArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ByteArray> CreateByteArrayDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  return CreateByteArray(_fbb, data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

struct ShortArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint16_t> *data() const { return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_DATA); }
  flatbuffers::Vector<uint16_t> *mutable_data() { return GetPointer<flatbuffers::Vector<uint16_t> *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct ShortArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> data) { fbb_.AddOffset(ShortArray::VT_DATA, data); }
  ShortArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShortArrayBuilder &operator=(const ShortArrayBuilder &);
  flatbuffers::Offset<ShortArray> Finish() {
    auto o = flatbuffers::Offset<ShortArray>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ShortArray> CreateShortArray(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> data = 0) {
  ShortArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShortArray> CreateShortArrayDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *data = nullptr) {
  return CreateShortArray(_fbb, data ? _fbb.CreateVector<uint16_t>(*data) : 0);
}

struct IntArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint32_t> *data() const { return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA); }
  flatbuffers::Vector<uint32_t> *mutable_data() { return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct IntArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) { fbb_.AddOffset(IntArray::VT_DATA, data); }
  IntArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  IntArrayBuilder &operator=(const IntArrayBuilder &);
  flatbuffers::Offset<IntArray> Finish() {
    auto o = flatbuffers::Offset<IntArray>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<IntArray> CreateIntArray(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  IntArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntArray> CreateIntArrayDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *data = nullptr) {
  return CreateIntArray(_fbb, data ? _fbb.CreateVector<uint32_t>(*data) : 0);
}

struct FloatArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const flatbuffers::Vector<float> *data() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA); }
  flatbuffers::Vector<float> *mutable_data() { return GetPointer<flatbuffers::Vector<float> *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct FloatArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) { fbb_.AddOffset(FloatArray::VT_DATA, data); }
  FloatArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FloatArrayBuilder &operator=(const FloatArrayBuilder &);
  flatbuffers::Offset<FloatArray> Finish() {
    auto o = flatbuffers::Offset<FloatArray>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<FloatArray> CreateFloatArray(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  FloatArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<FloatArray> CreateFloatArrayDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  return CreateFloatArray(_fbb, data ? _fbb.CreateVector<float>(*data) : 0);
}

struct Image2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FORMAT = 4,
    VT_WIDTH = 6,
    VT_HEIGHT = 8,
    VT_ELEMENTSIZE = 10,
    VT_PIXELS_TYPE = 12,
    VT_PIXELS = 14
  };
  const ImageFormat *format() const { return GetStruct<const ImageFormat *>(VT_FORMAT); }
  ImageFormat *mutable_format() { return GetStruct<ImageFormat *>(VT_FORMAT); }
  uint32_t width() const { return GetField<uint32_t>(VT_WIDTH, 0); }
  bool mutate_width(uint32_t _width) { return SetField(VT_WIDTH, _width); }
  uint32_t height() const { return GetField<uint32_t>(VT_HEIGHT, 0); }
  bool mutate_height(uint32_t _height) { return SetField(VT_HEIGHT, _height); }
  uint32_t elementSize() const { return GetField<uint32_t>(VT_ELEMENTSIZE, 0); }
  bool mutate_elementSize(uint32_t _elementSize) { return SetField(VT_ELEMENTSIZE, _elementSize); }
  PixelData pixels_type() const { return static_cast<PixelData>(GetField<uint8_t>(VT_PIXELS_TYPE, 0)); }
  bool mutate_pixels_type(PixelData _pixels_type) { return SetField(VT_PIXELS_TYPE, static_cast<uint8_t>(_pixels_type)); }
  const void *pixels() const { return GetPointer<const void *>(VT_PIXELS); }
  void *mutable_pixels() { return GetPointer<void *>(VT_PIXELS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImageFormat>(verifier, VT_FORMAT) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENTSIZE) &&
           VerifyField<uint8_t>(verifier, VT_PIXELS_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PIXELS) &&
           VerifyPixelData(verifier, pixels(), pixels_type()) &&
           verifier.EndTable();
  }
};

struct Image2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(const ImageFormat *format) { fbb_.AddStruct(Image2D::VT_FORMAT, format); }
  void add_width(uint32_t width) { fbb_.AddElement<uint32_t>(Image2D::VT_WIDTH, width, 0); }
  void add_height(uint32_t height) { fbb_.AddElement<uint32_t>(Image2D::VT_HEIGHT, height, 0); }
  void add_elementSize(uint32_t elementSize) { fbb_.AddElement<uint32_t>(Image2D::VT_ELEMENTSIZE, elementSize, 0); }
  void add_pixels_type(PixelData pixels_type) { fbb_.AddElement<uint8_t>(Image2D::VT_PIXELS_TYPE, static_cast<uint8_t>(pixels_type), 0); }
  void add_pixels(flatbuffers::Offset<void> pixels) { fbb_.AddOffset(Image2D::VT_PIXELS, pixels); }
  Image2DBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Image2DBuilder &operator=(const Image2DBuilder &);
  flatbuffers::Offset<Image2D> Finish() {
    auto o = flatbuffers::Offset<Image2D>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<Image2D> CreateImage2D(flatbuffers::FlatBufferBuilder &_fbb,
    const ImageFormat *format = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    uint32_t elementSize = 0,
    PixelData pixels_type = PixelData_NONE,
    flatbuffers::Offset<void> pixels = 0) {
  Image2DBuilder builder_(_fbb);
  builder_.add_pixels(pixels);
  builder_.add_elementSize(elementSize);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_format(format);
  builder_.add_pixels_type(pixels_type);
  return builder_.Finish();
}

struct Image3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FORMAT = 4,
    VT_WIDTH = 6,
    VT_HEIGHT = 8,
    VT_DEPTH = 10,
    VT_ELEMENTSIZE = 12,
    VT_PIXELS_TYPE = 14,
    VT_PIXELS = 16
  };
  const ImageFormat *format() const { return GetStruct<const ImageFormat *>(VT_FORMAT); }
  ImageFormat *mutable_format() { return GetStruct<ImageFormat *>(VT_FORMAT); }
  uint32_t width() const { return GetField<uint32_t>(VT_WIDTH, 0); }
  bool mutate_width(uint32_t _width) { return SetField(VT_WIDTH, _width); }
  uint32_t height() const { return GetField<uint32_t>(VT_HEIGHT, 0); }
  bool mutate_height(uint32_t _height) { return SetField(VT_HEIGHT, _height); }
  uint32_t depth() const { return GetField<uint32_t>(VT_DEPTH, 0); }
  bool mutate_depth(uint32_t _depth) { return SetField(VT_DEPTH, _depth); }
  uint32_t elementSize() const { return GetField<uint32_t>(VT_ELEMENTSIZE, 0); }
  bool mutate_elementSize(uint32_t _elementSize) { return SetField(VT_ELEMENTSIZE, _elementSize); }
  PixelData pixels_type() const { return static_cast<PixelData>(GetField<uint8_t>(VT_PIXELS_TYPE, 0)); }
  bool mutate_pixels_type(PixelData _pixels_type) { return SetField(VT_PIXELS_TYPE, static_cast<uint8_t>(_pixels_type)); }
  const void *pixels() const { return GetPointer<const void *>(VT_PIXELS); }
  void *mutable_pixels() { return GetPointer<void *>(VT_PIXELS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ImageFormat>(verifier, VT_FORMAT) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_DEPTH) &&
           VerifyField<uint32_t>(verifier, VT_ELEMENTSIZE) &&
           VerifyField<uint8_t>(verifier, VT_PIXELS_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PIXELS) &&
           VerifyPixelData(verifier, pixels(), pixels_type()) &&
           verifier.EndTable();
  }
};

struct Image3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(const ImageFormat *format) { fbb_.AddStruct(Image3D::VT_FORMAT, format); }
  void add_width(uint32_t width) { fbb_.AddElement<uint32_t>(Image3D::VT_WIDTH, width, 0); }
  void add_height(uint32_t height) { fbb_.AddElement<uint32_t>(Image3D::VT_HEIGHT, height, 0); }
  void add_depth(uint32_t depth) { fbb_.AddElement<uint32_t>(Image3D::VT_DEPTH, depth, 0); }
  void add_elementSize(uint32_t elementSize) { fbb_.AddElement<uint32_t>(Image3D::VT_ELEMENTSIZE, elementSize, 0); }
  void add_pixels_type(PixelData pixels_type) { fbb_.AddElement<uint8_t>(Image3D::VT_PIXELS_TYPE, static_cast<uint8_t>(pixels_type), 0); }
  void add_pixels(flatbuffers::Offset<void> pixels) { fbb_.AddOffset(Image3D::VT_PIXELS, pixels); }
  Image3DBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Image3DBuilder &operator=(const Image3DBuilder &);
  flatbuffers::Offset<Image3D> Finish() {
    auto o = flatbuffers::Offset<Image3D>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Image3D> CreateImage3D(flatbuffers::FlatBufferBuilder &_fbb,
    const ImageFormat *format = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    uint32_t depth = 0,
    uint32_t elementSize = 0,
    PixelData pixels_type = PixelData_NONE,
    flatbuffers::Offset<void> pixels = 0) {
  Image3DBuilder builder_(_fbb);
  builder_.add_pixels(pixels);
  builder_.add_elementSize(elementSize);
  builder_.add_depth(depth);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_format(format);
  builder_.add_pixels_type(pixels_type);
  return builder_.Finish();
}

struct DoubleBuffer2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT__FRONT = 4,
    VT__BACK = 6
  };
  const Image2D *_front() const { return GetPointer<const Image2D *>(VT__FRONT); }
  Image2D *mutable__front() { return GetPointer<Image2D *>(VT__FRONT); }
  const Image2D *_back() const { return GetPointer<const Image2D *>(VT__BACK); }
  Image2D *mutable__back() { return GetPointer<Image2D *>(VT__BACK); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT__FRONT) &&
           verifier.VerifyTable(_front()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT__BACK) &&
           verifier.VerifyTable(_back()) &&
           verifier.EndTable();
  }
};

struct DoubleBuffer2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add__front(flatbuffers::Offset<Image2D> _front) { fbb_.AddOffset(DoubleBuffer2D::VT__FRONT, _front); }
  void add__back(flatbuffers::Offset<Image2D> _back) { fbb_.AddOffset(DoubleBuffer2D::VT__BACK, _back); }
  DoubleBuffer2DBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DoubleBuffer2DBuilder &operator=(const DoubleBuffer2DBuilder &);
  flatbuffers::Offset<DoubleBuffer2D> Finish() {
    auto o = flatbuffers::Offset<DoubleBuffer2D>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DoubleBuffer2D> CreateDoubleBuffer2D(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Image2D> _front = 0,
    flatbuffers::Offset<Image2D> _back = 0) {
  DoubleBuffer2DBuilder builder_(_fbb);
  builder_.add__back(_back);
  builder_.add__front(_front);
  return builder_.Finish();
}

struct DoubleBuffer3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT__FRONT = 4,
    VT__BACK = 6
  };
  const Image3D *_front() const { return GetPointer<const Image3D *>(VT__FRONT); }
  Image3D *mutable__front() { return GetPointer<Image3D *>(VT__FRONT); }
  const Image3D *_back() const { return GetPointer<const Image3D *>(VT__BACK); }
  Image3D *mutable__back() { return GetPointer<Image3D *>(VT__BACK); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT__FRONT) &&
           verifier.VerifyTable(_front()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT__BACK) &&
           verifier.VerifyTable(_back()) &&
           verifier.EndTable();
  }
};

struct DoubleBuffer3DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add__front(flatbuffers::Offset<Image3D> _front) { fbb_.AddOffset(DoubleBuffer3D::VT__FRONT, _front); }
  void add__back(flatbuffers::Offset<Image3D> _back) { fbb_.AddOffset(DoubleBuffer3D::VT__BACK, _back); }
  DoubleBuffer3DBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DoubleBuffer3DBuilder &operator=(const DoubleBuffer3DBuilder &);
  flatbuffers::Offset<DoubleBuffer3D> Finish() {
    auto o = flatbuffers::Offset<DoubleBuffer3D>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DoubleBuffer3D> CreateDoubleBuffer3D(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Image3D> _front = 0,
    flatbuffers::Offset<Image3D> _back = 0) {
  DoubleBuffer3DBuilder builder_(_fbb);
  builder_.add__back(_back);
  builder_.add__front(_front);
  return builder_.Finish();
}

inline bool VerifyPixelData(flatbuffers::Verifier &verifier, const void *union_obj, PixelData type) {
  switch (type) {
    case PixelData_NONE: return true;
    case PixelData_ByteArray: return verifier.VerifyTable(reinterpret_cast<const ByteArray *>(union_obj));
    case PixelData_ShortArray: return verifier.VerifyTable(reinterpret_cast<const ShortArray *>(union_obj));
    case PixelData_IntArray: return verifier.VerifyTable(reinterpret_cast<const IntArray *>(union_obj));
    case PixelData_FloatArray: return verifier.VerifyTable(reinterpret_cast<const FloatArray *>(union_obj));
    default: return false;
  }
}

}  // namespace schemas
}  // namespace ogmaneo

#endif  // FLATBUFFERS_GENERATED_HELPERS_OGMANEO_SCHEMAS_H_
